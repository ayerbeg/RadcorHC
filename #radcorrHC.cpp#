// NOTES:
// The output folders must be constructed previously to run the script
#include "Rtypes.h"

#include <iostream>
#include <fstream>
#include <stdio.h>
#include "TApplication.h"
#include "TFile.h"
#include "TTree.h"
#include "TCanvas.h"
#include "TGraph.h"
#include "TH1.h"
#include "TF1.h"
#include "TLine.h"
#include <TROOT.h>
#include <TStyle.h>
#include <vector>
#include <math.h>
#include "TStopwatch.h"
#include <sstream>
#include "TSystem.h"
#include "TString.h"

#include <iomanip> //library for precision()



#include "HCVariables.hh"
#include "HCSelectProcess.hh"

using namespace std;


// Order and declaration of the arguments:(i)file_idx, (d)W2, (d)Q2, (c)Target, (i)YoniIndex, (i)IPOL, (i)IA1, (i)SFC, (i)Asym, (c)reso, (d)F1, (d)F2, (d)g1, (d)g2, (d)A1, (d)A2
extern"C"{
  void strucfunc_(int *, double *, double *, char *, int *, int *, int *, int *, int *, char *, double *, double *, double *, double *, double *, double *);
}


void clas_model(TString,
		TString,
		double,
		vector<vector<double>>,
		vector<vector<double>>,
		vector<vector<double>>,
		vector<vector<double>> &,
		vector<vector<double>>&);

double calcQ2(double, double, double);
double calcW2(double, double, double);
void  PlotSF(vector<double>, vector<double>,  vector<double>);
void  PlotHe3XS(vector<double> , vector<double>);
void MakeCross(vector<vector<double>>,
	       vector<vector<double>>,
	       vector<vector<double>>,
	       vector<vector<double>>,
	       vector<vector<double>>,
	       vector<vector<double>>,
	       TString);
double He3CrossSection( Double_t ,  Double_t , Double_t , Double_t ,  Double_t );

//*******************************************
// GLOBAL VARIABLES (MAYBE MOVE TO A HEADER)

bool plotPhaseSpace = 0;
bool plotStructureF = 0;
bool plotCrossSecHe3 = 0;
//stringVariables-> plotStructureFrep;


//*******************************************

void create_space_phase(TString,
			TString,
			double,
			vector<double> &,
			vector<double> &);

void CreateSpectra(TString,
		   TString,
		   double,
		   vector<Double_t>,
		   vector<Double_t> ,
		   TString &,
		   vector<vector<double>> &,
		   vector<vector<double>> &,
		   vector<vector<double>> &);

Double_t round_number2(Double_t);
Double_t round_number3(Double_t);


void Plot_phase_space(vector<Double_t>, vector<Double_t>, double, double, double, double, double);

void variable(TString );
bool ReadBoolean(string);
void Target_rad(double &, int &);

//void SelectProcess(double, int, TString);






// NOTEL start to remove the round functions. I am not sure how they will carry the further calculations
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

void create_space_phase(TString mainFolder,
			double mNuc,
			vector<double> &vEs_PS,
			vector<double> &vEp_PS )
{

  //***************  KIN SET  ************************
  cout<<"********create space phase*****************"<<endl;
  
  

  // Angle of the spectrometer (kinematics) in rad
  cout<<"Theta: "<<Variables->gTheta<<endl;
  double Theta =  Variables->gTheta/rad2deg; // min acceptance angle Murchana thesis
  
  Double_t sinsq = pow(sin((Theta)/2.),2); //sin^2(theta/2) --> just to simplify

  
  // Es_max = E_beam --> Max Es corresponds to energy beam.
    
  Double_t Es_max = Variables->  gBeam ;
  Double_t Es_min;

  
  // IN PRINCIPLE, Variables->Ep_min should be determine by the experiment
  Double_t Ep_max;

  // I am using round_number to keep certain limited precision. Somehow it is legacy of how Melanie
  // presented her data. 
  Es_min = round_number2((W2threshold - pow(mNuc,2) + 2*mNuc*Variables->Ep_min )/( 2*mNuc - 4*Variables->Ep_min  *sinsq) );
  Ep_max   = ( pow(mNuc,2) + 2*mNuc*Es_max - W2threshold )/( 2*mNuc + 4*Es_max*sinsq);
  
  


  // the phase-space folder
  TString PSinfo = mainFolder+"/PS_limits";
  gSystem->MakeDirectory(PSinfo);   

  // the phase-space data
  ofstream outfile;
  outfile.open(Form(PSinfo+"/Theta.%.2f.Eprime.%.2f.dat", Theta*rad2deg, Variables->Ep_min  ) );  

  
  Int_t Esbins;
   
	    
  cout<<"Es_min: "<<(W2threshold - pow(mNuc,2) + 2*mNuc*Variables->Ep_min )/( 2*mNuc - 4*Variables->Ep_min  *sinsq)<<endl;
  
  cout<<"mNuc: "<<mNuc<<endl;
  
  // I don't need to store the round maximum value, but it is calculated for sanity

  // My intention is to create a general code, but it is greatly dependent of certain values
  // like the energy beam. For instance we want 0.1 GeV space bins in Es, but the last bin, can only
  // 0.08 so it needed to be hard codes. Maybe, we can make a code to determine when the division is
  // not exact and add the last bin.
  
  // we need to calculate the number of bins from Es_min and Es_max (10.300) with 0.1 GeV spacing
  // because we round Es_min up to two significatn figures, we assure that the number of bins
  // is integer, not just because we defined it integer (that would truncate the number)
  // Last bin, as suggested by Melanie's theses, will be of 0.8 and added later

  double EsBinSize = 0.1;
  Esbins = ((Es_max - 0.080 ) - Es_min  ) /(EsBinSize );

    //*****************************************************************
  // These lines created the spectrum of Ep vs Es in steps of 0.1 GeV
  // and rounded to the 3rd decimal
  //*****************************************************************
  for (int Esidx = 0; Esidx <= Esbins; Esidx++)
    {
      vEs_PS.push_back(Es_min + EsBinSize *Esidx);
  
      vEp_PS.push_back(round_number3(( pow(mNuc,2) + 2*mNuc*vEs_PS[Esidx] - W2threshold)/( 2*mNuc + 4*vEs_PS[Esidx]*sinsq) ) );
    }
  
  // This extra line is to include the last bin which won't fit the bin separation criteria odf 0.1GeV
  vEs_PS.push_back(Es_max);
  vEp_PS.push_back(round_number3(( pow(mNuc,2) + 2*mNuc*vEs_PS[Esbins+1] - W2threshold) /( 2*mNuc + 4*vEs_PS[Esbins+1]*sinsq)) );
  
  	  
  //*********************************************************************************
  // These lines store in a ASCII file the Ep-bin vs Es-bin for each Variables->Ep_min and Theta
  // rounded to the second decimal (Es) and third decimal (Ep)
  // Also creates the folder with the .dat files with the steps to feed the models
   for (int gr_idx0 = 0; gr_idx0 < vEs_PS.size(); gr_idx0++)
   {
      outfile << fixed << setprecision(3) << vEs_PS[gr_idx0] <<" " << vEp_PS[gr_idx0] <<"\n";
   }
  //*********************************************************************************

  //	   cout<<"Es size: "<< vgrEsELA  .size()<<" Ep size: "<< vgrEpELA  .size()<<" ELABins: "<< ELAbins<<endl;  
  outfile.close();
  
  if (plotPhaseSpace)
    Plot_phase_space(vEs_PS, vEp_PS, Es_min,Es_max, Variables->Ep_min,Ep_max, Theta );


  return;
}




//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

void CreateSpectra(TString mainFolder,
		   TString nucFolder,
		   double (CSEp_min),
		   vector<double> vgrEs,
		   vector<double> vgrEp,
		   TString &folder02,
		   vector<vector<double>> &vvEsCS,
		   vector<vector<double>> &vvEpCS,
		   vector<vector<double>> &vvnuCS)
{

  cout<<"*******create spectra*************"<<endl;
  

  double Theta =  Variables->gTheta/rad2deg;
  cout<<"Theta: "<<Variables->gTheta<<endl;
  
  TString angle_fol;

  angle_fol = Form("/%2.2f", Theta *rad2deg);
  
  TString folder01= mainFolder+angle_fol+"deg/"; 
  folder02= folder01+nucFolder;
 
  gSystem->MakeDirectory(folder01);
  gSystem->MakeDirectory(folder02); 

  // The folder02 is the FinalFolder used internally in the rest of the code
  // it is specific for the angle set in options.ini
  // Perhaps it should be improved for similar angle but other characteristics
  // as is right now, it will overwrite any data present.

  // Keeping the philosophy of working without reading any of the created files
  // we need to store the output here in containers to send to the next method
  // but we save the data as was done with the single scripts

  ofstream spectra;
  
  Int_t file_id = 0;

  Double_t Es, Ep;

  Int_t file_idx =0;
  Double_t nu, EpDelta;

  // These vectors contain the data of a given Es bin
  vector<double> vEs;
  vector<double> vEp;
  vector<double> vnu;

  // These vectors contain all the spectra
  // vector<vector<double>> vvEsCS;
  // vector<vector<double>> vvEpCS;
  // vector<vector<double>> vvnuCS;
  
  int NoEsBins = vgrEs.size();
  Double_t delta = 0;


  
  gSystem->MakeDirectory(folder02+"/spectra");
  
  for (int idx = 0; idx< NoEsBins; idx++)
    {
      Es = vgrEs[idx];
      Ep = vgrEp[idx];
      EpDelta = Ep;

      
      TString fileDIS = folder02+"/spectra"+Form("/%d.dat", file_id );

      spectra.open(fileDIS);
      
      while( EpDelta >=(CSEp_min -(0.001) ) )
	{
	  nu = Es - EpDelta;
	  vEs.push_back(Es);
	  vEp.push_back(EpDelta);
	  vnu.push_back(nu);
	  
	  spectra<< Es<<" "<<EpDelta<<" "<<nu<<"\n";
	  delta++;
	  EpDelta = Ep - 0.01* delta;
	}

      // There are two ways to pass the data to the clas model
      // I can pass it as the spectrum is created
      // so, just need to call the function here and pass
      // the vector with the info of the present spectra
      // The other option, used here, is to pass the whole information
      // Probably, in memory usage, the first is more efficient
      
      vvnuCS.push_back(vnu);
      vvEsCS.push_back(vEs);
      vvEpCS.push_back(vEp);

      vEs.clear();
      vEp.clear();
      vnu.clear();
      
      spectra.close();
      file_id++;
      // clas_model method should be called here.
      // the arguments should be vectors of Es, Ep(steps), nu, file_id
      delta = 0;

    }

  cout<<"size: "<<vvnuCS.size()<<endl;
  
}





//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

void clas_model(TString storeFolderCM,
		TString nucleonCM,
		double mNuc,
		vector<vector<double>>EsCM,
		vector<vector<double>>nuCM,
		vector<vector<double>>EpCM,
		vector<vector<double>> &vvF1CM,
		vector<vector<double>> &vvF2CM
		)
{

  cout<<"***********Clas model***************"<<endl;
  cout<<storeFolderCM<<endl;


  double Theta =  Variables->gTheta/rad2deg;
  cout<<"Theta: "<<Variables->gTheta<<endl;
  // These lines are necesary to simplify the conversion from
  // string to char needed by the fortran subroutine
  char creso;
  if( (Variables->varreso == "y")||(Variables->varreso == "Y"))
    {
      creso = 'y' ;
    }
  else
    {
      creso = 'n' ;
    }
  
  char Target; // A lot to understand here.

  int typeTarget;
  //  Target_rad(mNuc, typeTarget); // it doesn't work when the target is He3

  const char* nucle;  
  // Same as before (remember we are using global variables)
  if(nucleonCM == "proton")
    {
      Target = 'P';
      nucle = "p";  
    }
  else
    {
      Target = 'N';
      nucle = "n";  
    }

  
 


  // SF data/spectra
  vector<double> vF1;
  vector<double> vF2;



  
  // THE RETURNED VALUES ACCORDING TO DARREN UPTON DOCUMENT
  // MAYBE WE DON'T NEED ALL OF THEM FOR THE RADIATIVE CORRECTIONS
  // BUT WE CAN KEEP THEM FOR FURTHER ANALYSIS

  Double_t Q2;  // transfer momentum
  Double_t W2;  // invariant mass
  Double_t xbj; // x Bjorken
  Double_t F1=0;  // unpolarized SF1
  Double_t F2=0;  // unpolarized SF2
  Double_t R;   // ?
  Double_t A1;  // asymmetry A1
  Double_t A2;  // asymmetry A2 (?)
  Double_t g1=0;  // polarized SF1
  Double_t g2=0;  // polarized SF2


  string line;
  string it1, it2, it3; // MY FILES HAVE Es, Ep and nu = (Es-Ep)
  Double_t Es, Ep, nu;


  int SFC = Variables-> varSFC ;
  int Asym = Variables-> varAsym;
  int IA1 = Variables->varIA1;
  int IPOL = Variables->varIPOL; 
  int YoniIndex = Variables->varYoniIndex;
 cout<<  IPOL<<" "<<IA1<<" "<< Asym<<" "<<Target<<endl;
  
  
  Int_t file_id = 0;


  bool fileexist = true;


  TString SaveData = Form(storeFolderCM+"/SF%s",nucle);
  gSystem->MakeDirectory(SaveData);


  cout<< SaveData<<endl;  
  // THIS LOOP KEEPS READING THE FILES IN A GIVEN FOLDER (THE ONE DEFDISD BY Ep)


  int NoOfSpectra = EsCM.size();// somehow, this is the number of spectra (the file id)
  cout<<"Hello "<< NoOfSpectra<<endl;
  
  for(int spectraIDX = 0; spectraIDX < NoOfSpectra; spectraIDX++)
    {
   
      int NoOfPoints = EsCM[spectraIDX].size();// this is the number of data points in the spectra
      file_id = spectraIDX;

      ofstream SaveFile(SaveData+Form("/%sSF_%d.dat",Theta*rad2deg,  nucle, file_id ));
 
      for(int SpecPointsIDX = 0; SpecPointsIDX < NoOfPoints; SpecPointsIDX++)
	{

	  Es = EsCM[spectraIDX][SpecPointsIDX];
	  Ep = EpCM[spectraIDX][SpecPointsIDX]; 
	  nu = nuCM[spectraIDX][SpecPointsIDX]; 
  

	  Q2 = calcQ2(Es,Ep, Theta );
	  W2 = calcW2(mNuc, nu, Q2);

	  
	  strucfunc_(&file_id, &W2, &Q2, &Target, &YoniIndex, &IPOL, &IA1, &SFC, &Asym, &creso, &F1, &F2, &g1, &g2, &A1, &A2 );

	  // with the option 'fixed' every value carries the same number of digits, filling with zeroes when necessary
	  // Data saved: Es -- nu -- W2 -- Q2 -- F1 -- F2 -- g1 -- g2
	  SaveFile<<fixed<<Es<<"\t"<<nu<<"\t" << W2 <<"\t"<<Q2<<"\t"<< F1<<"\t"<< F2<<"\t"<< g1<<"\t"<< g2 << endl;
	  //	  cout<<fixed<<Es<<"\t"<<nu<<"\t" << W2 <<"\t"<<Q2<<"\t"<< F1<<"\t"<< F2<<"\t"<< g1<<"\t"<< g2 << endl;

	  vF1.push_back(F1);
	  vF2.push_back(F2);
	}
      
      vvF1CM.push_back(vF1);
      vvF2CM.push_back(vF2);

      vF1.clear();
      vF2.clear();
      SaveFile.close();
     }

  if(  plotStructureF) // it plots THE LAST bin of the phase-space (the list starts at 0)
    PlotSF(nuCM[NoOfSpectra-1], vvF1CM[NoOfSpectra-1],  vvF2CM[NoOfSpectra-1]);


    
  // can we combine the previous work in order to calculate THIS:
  //  XS = CrossSection(Es, nu, Theta, 2*pF1+nF1,  2*pF2+nF2);
  // probably it needs an extra function where it call the method twice

}





//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-



  
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

// suffix MC for MakeCross (this function)
void MakeCross(vector<vector<double>> vvEsMC,
	       vector<vector<double>> vvnuMC,
	       vector<vector<double>> vvF1neuMC,
	       vector<vector<double>> vvF2neuMC,
	       vector<vector<double>> vvF1proMC,
	       vector<vector<double>> vvF2proMC,
	       TString SaveFolder)
{
  cout<<"*********** Make Cross ***************"<<endl;

  double Theta =  Variables->gTheta/rad2deg;
  cout<<"Theta: "<<Variables->gTheta<<endl;
  TString SaveData =(SaveFolder + Form("/%2.2fdeg/He3CrossSection", Theta *rad2deg));
  gSystem->MakeDirectory(SaveData);
  cout<<SaveData<<endl;

  
  Double_t Es, nu, Ep,  W2, Q2, g1, g2; // Es and nu are common for n and p, W2 and Q2 are not used. g1 and g2 are in stand-by
  Double_t pF1, pF2, nF1, nF2;

  Double_t XS;

  vector<double> vXS;
  vector<vector<double>> vvXS;

  double mHe3 = 2.81 ;// GeV. 3 uma

  int NoOfSpectra = vvEsMC.size();// somehow, this is the number of spectra (the file id)
  cout<<"Hello "<< NoOfSpectra<<endl;

  cout<<vvnuMC.size()<<" "<<vvF1neuMC.size()<<" "<<vvF2neuMC.size()<<" "<<vvF1proMC.size()<<" "<<vvF1proMC.size()<<endl;
  
  Int_t file_id = 0;
  for(int spectraIDX = 0; spectraIDX < NoOfSpectra; spectraIDX++)
    {
 
      int NoOfPoints = vvEsMC[spectraIDX].size();// this is the number of data points in the spectra
      file_id = spectraIDX;

      ofstream  SaveFile(SaveData +Form("/XS%2.2f_%d.dat", Theta*rad2deg, file_id ));
 
      for(int SpecPointsIDX = 0; SpecPointsIDX < NoOfPoints; SpecPointsIDX++)
	{

	  // All units are in GeV, but the cross-section is handled in MeV
	  // so, we convert all to MeV (1e3) but at the end of the process
	  
	  Es = vvEsMC[spectraIDX][SpecPointsIDX]; 
	  nu = vvnuMC[spectraIDX][SpecPointsIDX]; 
	  
	  Q2 = calcQ2(Es, Es-nu, Theta); 
	  W2 = calcW2(mHe3, nu, Q2)*pow(1e3,2);       //in MeV^2

	  
	  pF1 = vvF1proMC[spectraIDX][SpecPointsIDX];   
	  pF2 = vvF2proMC[spectraIDX][SpecPointsIDX]; 
	  
	  nF1 = vvF1neuMC[spectraIDX][SpecPointsIDX];  
	  nF2 = vvF2neuMC[spectraIDX][SpecPointsIDX];  
	  
	  XS = He3CrossSection(Es*1e3, nu*1e3, Theta, 2*pF1+nF1,  2*pF2+nF2);
	  
	  SaveFile<< Es*1e3 << "\t" <<nu*1e3  << "\t"<< sqrt(W2) << "\t" <<XS<<"\t"<<0.0<<endl;
	  //	  cout<<fixed<< Es*1e3 << "\t" <<nu*1e3  << "\t"<< sqrt(W2) << "\t" <<XS<<"\t"<<0.0<<endl;
	  vXS.push_back(XS);
	}
      vvXS.push_back(vXS);
      vXS.clear();
      SaveFile.close();
    }


  
  cout<<"bool: "<<plotCrossSecHe3<<endl;
  if( plotCrossSecHe3)
    PlotHe3XS(vvnuMC[NoOfSpectra-1], vvXS[NoOfSpectra-1]);

}


//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

double He3CrossSection( Double_t tE,  Double_t tnu, Double_t  tAngle, Double_t  tF1,  Double_t tF2)
{
  // tE incoming energy, tnu energy difference, tAngle scattering angle, tF1 = F1n + 2F1p (same F2)
  // units converted already in MeV from GeV


  // I think I missed a factor cos^2 in the formula
  
  double mHe3 = 2.81*1e3;//in MeV  3 uma
  double alpha = 1/137.;
  double hbarc = 197.32698;
  double mott = pow(alpha, 2)/(4*(tE*tE)*pow(sin(tAngle/2.), 4));
  double cross =pow(cos(tAngle/2.), 2)* ((tF2/(tnu))+((2*tF1*pow(tan(tAngle/2.), 2))/mHe3));
  
  return mott*cross*(hbarc*hbarc)*1e7;
  // the convertion factor from 1/MeV^3 -> nb/MeV
}


//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

double calcQ2(double Ei, double Ef, double Th)
{
  return Ei*Ef*4*sin(Th/2.)*sin(Th/2.);
}
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
double calcW2(double mp, double nulocal, double Q2local)
{
  return mp*mp + (2*mp*nulocal) - Q2local;
}
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-









//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

void Plot_phase_space(vector<Double_t> vgrEsDIS, vector<Double_t> vgrEpDIS, double Es_min,double Es_max, double PPSEp_min,double Ep_max, Double_t Theta )
{
  //************** GRAPH THE PHASE-SPACE*****************
  //***  although it seems to have the same loops as  ***
  //***  shown above, these lopps cannot be avoided   ***
  //***  because they need to work with already       ***
  //***  calculated values, not on the fly            ***
  //*****************************************************

  TCanvas *c2;
  c2 = new TCanvas("c2","A Simple Graph Example",200,10,700,500);
  // c2->Divide(5,2);
  c2->cd();
     
   
  TGraph *grDIS;
  TAxis *axisDIS; 
  TLine *DISlineH;
  TLine *DISlineV;
  
    TLine *INElineStepV[100];
  TLine *INElineStepH[100];
      
  grDIS   = new TGraph(vgrEsDIS  .size(), &vgrEsDIS  [0] , &vgrEpDIS  [0]);

  // These values should be estimated from the kinematics
  // axisDIS = grDIS  ->GetXaxis();
  // axisDIS -> SetLimits(5. ,11. ); 
  //  grDIS   -> GetHistogram()->SetMaximum(8. );   // along          
  //  grDIS   -> GetHistogram()->SetMinimum(3. ); 
    
    
    
  grDIS   ->SetFillColor(10);
  grDIS   ->SetLineColor(kPink);
  grDIS   ->SetLineWidth(4);
  grDIS   ->SetMarkerColor(4);
  grDIS   ->SetMarkerStyle(8);

  grDIS   ->SetTitle(Form("Phase Space HMS Kin A -- #Theta = %.2f deg", Theta *rad2deg) );
  grDIS   ->Draw("AL");
  grDIS   ->GetHistogram()->SetXTitle("Es (MeV)");
  grDIS   ->GetHistogram()->SetYTitle("Ep (MeV)");
      

  DISlineH   = new TLine(Es_min   ,  PPSEp_min  , Es_max,  PPSEp_min  );
  DISlineH   ->SetLineWidth(4);
  DISlineH   ->SetLineColor(kPink);
  DISlineH   ->Draw("same");
	   
	   
  DISlineV    = new TLine(Es_max, PPSEp_min  , Es_max, Ep_max   );
  DISlineV    ->SetLineWidth(4);
  DISlineV    ->SetLineColor(kPink);
  DISlineV    ->Draw("same");
  /*	   
  for (int stepH = 0; stepH < 47; stepH++)
     {
       INElineStepV[stepH]  = new TLine(Es_min+ (0.1*stepH ), Variables->Ep_min, Es_min+ (0.1*stepH ), Ep_max );
       INElineStepV[stepH]  ->SetLineWidth(1);
       INElineStepV[stepH]  ->SetLineColor(kBlack);
       INElineStepV[stepH]  ->Draw("same");
     }
   
   for (int stepV = 0; stepV < 39; stepV++)
     {
       INElineStepH[stepV]  = new TLine(Es_min, Variables->Ep_min + (0.1*stepV ) , Es_max, Variables->Ep_min + (0.1*stepV ) );
       INElineStepH[stepV]  ->SetLineWidth(1);
       INElineStepH[stepV]  ->SetLineColor(kBlack);
       INElineStepH[stepV]  ->Draw("same");
     }
  */
}




void PlotSF(vector<double>vnuPlot, vector<double>vvF1Plot,  vector<double>vvF2Plot)
{

  double Theta =  Variables->gTheta/rad2deg;
  cout<<"Theta: "<<Variables->gTheta<<endl;

  double eBeam =Variables->  gBeam;
  // This function plots the last bin of the calculated Phase-Space previously
  // The last bin is supposed to be Es=Ebeam=10.38.
  const char* nucle;  
  // Same as before (remember we are using global variables)

  cout<<"nucle: "<<Variables->nucleon<<endl;

  if(Variables->nucleon == "proton")
    {
      nucle = "p";  
    }
  else
    {
      nucle = "neutron";  
    }
  

  for(int yy = 0; yy< vnuPlot.size(); yy++)
    {
      vnuPlot[yy] = 10.38-vnuPlot[yy] ;
    }

  cout<<"nucle: "<<nucle<<endl;
  TCanvas *c3;
  c3 = new TCanvas("c3","F1 Structure Function",1);
  
  TGraph *grF1;
  grF1 = new TGraph(vnuPlot.size(), &vnuPlot[0], &vvF1Plot[0]);	 
  
  grF1 -> SetTitle(Form("F_{1}^{%s} - %.2fdeg - %.2f GeV - W=%.2f GeV threshold", nucle, Theta*rad2deg, eBeam, Variables->WThreshold) );
  grF1 -> GetHistogram()->SetXTitle("E' [GeV]");
  grF1 -> GetHistogram()->SetYTitle("F1 ");
  
  if(Variables->plotStructureFrep=="line")
    {
      grF1 -> SetLineWidth(4);
      grF1 -> SetLineColor(kRed);
      grF1 -> Draw("AL");
    }
  else
    {
      grF1 -> SetMarkerColor(kBlue);
      grF1 -> SetMarkerStyle(7);
      grF1 -> Draw("AP");
    }
  
  TCanvas *c4;
  c4 = new TCanvas("c4","F2 Structure Function",1);
  
  TGraph *grF2;
  grF2 = new TGraph(vnuPlot.size(), &vnuPlot[0], &vvF2Plot[0]);	 
    
  grF2 -> SetTitle(Form("F_{2}^{%s} - %.2fdeg - %.2f GeV - W=%.2f GeV threshold", nucle, Theta*rad2deg, eBeam,Variables->WThreshold) );
  grF2 -> GetHistogram()->SetXTitle("E' [GeV]");
  grF2 -> GetHistogram()->SetYTitle("F2 ");


    if(Variables->plotStructureFrep=="line")
    {
      grF2 -> SetLineWidth(4);
      grF2 -> SetLineColor(kRed);
      grF2 -> Draw("AL");
    }
  else
    {
      grF2 -> SetMarkerColor(kBlue);
      grF2 -> SetMarkerStyle(7);
      grF2 -> Draw("AP");
    }
  


  return;
}

//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
void PlotHe3XS(vector<double> vnu, vector<double> vXS)
{
  double Theta = Variables->gTheta;
  double W = Variables->WThreshold;
  cout<<W<<endl;


  for(int yy = 0; yy< vnu.size(); yy++)
    {
      vnu[yy] = 10.38-vnu[yy] ;
    }
  

  
  TCanvas *cHe3XS;
  cHe3XS = new TCanvas("cHeXS","He3 Cross Section",1);

  TGraph *grXS;
  //  grXS = new TGraph(vrnu.size(), &vrnu[0], &vXS[0]);
  grXS = new TGraph(vnu.size(), &vnu[0], &vXS[0]);	 

      
  TAxis *axisINE; 
  grXS  ->SetLineWidth(4);
  grXS ->SetMarkerColor(4);
  grXS ->SetLineColor(kRed);
  
  // axisINE =grXS ->GetXaxis();
  // axisINE -> SetLimits(20.,180.); 
  //grXS -> GetHistogram()->SetMinimum(0.);

  grXS -> SetTitle(Form("KIN A - %.2fdeg - 10.38GeV - W=%.2f GeV threshold", Theta, Variables->WThreshold ));
  grXS -> GetHistogram()->SetXTitle("#nu [GeV]");
  grXS -> GetHistogram()->SetYTitle("Cross-Section [nb/MeV/sr]");
  grXS -> Draw("AL");

  

}


//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-


// void Target_rad(double &mTar,int &tTar )
// {
//   // to the constants (in GeV)
//   double  mp = 0.938272 ;//proton mass
//   double  mn = 0.939565 ;//neutron mass
//   double  mHe3 = 2.81 ;// GeV. 3 uma
//   double  mpion = 0.140 ;// pion mass 


  
//   // Ideally, we should use SWITCH/CASE
//   // but switch doesn't handle strings very well

//   // Honestly, this function is a bit useless except to select
//   // the case, but the mass is redifined when we want to use He3 in the
//   // SelectProcess. Definetely, this could be simplified with a C++ style
//   if( Variables->nucleon == "neutron")
//     {
//       mTar = mn;
//       tTar = 0;
//     }
//   else  if( Variables->nucleon == "proton")
//     {
//       mTar = mp;
//       tTar = 1;
//     }
//   else  if( Variables->nucleon == "He3")
//     {
//       mTar = mHe3;
//       tTar = 3; // in the improbable case we want D2 in the future
//     }
//   else
//     {
//       cout << "Invalid Target" << endl;
//       exit(0);
//     }
        
//   //  cout<<"mTar: "<<mTar<<endl; 

//   return;
  
// }


//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

// void SelectProcess(double mTarget, int tTarget, TString WFolder)
// {
//   cout<<"typeTarget: "<<tTarget<<endl;

//   vector<double> vEs;
//   vector<double> vEp;

//   vector<double> vEspro;
//   vector<double> vEppro;

//   vector<double> vEsneu;
//   vector<double> vEpneu;


//   vector<vector<double>> vvEs;
//   vector<vector<double>> vvEp;
//   vector<vector<double>> vvnu;

//   // I believe that these vectors (pro/neu)
//   // content the same or similar values. 
//   // (update) Actuallym, they have similar values due to the
//   // round to the 2nd decimal. For sanity, I'll keep them separate.
//   vector<vector<double>> vvEspro;
//   vector<vector<double>> vvEppro;
//   vector<vector<double>> vvnupro;
  

//   vector<vector<double>> vvEsneu;
//   vector<vector<double>> vvEpneu;
//   vector<vector<double>> vvnuneu;

//   // The SF spectra 
//   vector<vector<double>> vvF1;
//   vector<vector<double>> vvF2;

//   vector<vector<double>> vvF1neu;
//   vector<vector<double>> vvF2neu;

//   vector<vector<double>> vvF1pro;
//   vector<vector<double>> vvF2pro;
  
 
//   TString FinalFolder;
  
//   double mn, mp;
  
//   switch(tTarget)
//     {
//       // neutron and proton phase-space are similar except for the mass
//       // WFolder is the folder created for the project (in options.ini)
//       // FinalFolder is the specific folder for a given angle (in options.ini)

//     case 0:
//     case 1:
//       create_space_phase(WFolder, mTarget, vEs, vEp);
//       CreateSpectra(WFolder, Variables->nucleon, Variables->Ep_min, vEs, vEp, FinalFolder, vvEs, vvEp, vvnu);

//       clas_model(FinalFolder, Variables->nucleon, mTarget, vvEs, vvnu, vvEp, vvF1, vvF2);

//       break;
//     case 3:
//       // first the neutron
//       mTarget = 0.939565 ;//neutron mass
//       create_space_phase(WFolder, mTarget, vEsneu, vEpneu);
//       CreateSpectra(WFolder, "neutron", Variables->Ep_min, vEsneu, vEpneu, FinalFolder, vvEsneu, vvEpneu, vvnuneu);

//       clas_model(FinalFolder, "neutron", mTarget, vvEsneu, vvnuneu, vvEpneu, vvF1neu, vvF2neu);
      
//       // second the proton
//       mTarget = 0.938272 ;
//       create_space_phase(WFolder, mTarget, vEspro, vEppro);
//       CreateSpectra(WFolder, "proton", Variables->Ep_min, vEspro, vEppro, FinalFolder, vvEspro, vvEppro, vvnupro);

//       clas_model(FinalFolder, "proton", mTarget, vvEspro, vvnupro, vvEppro, vvF1pro, vvF2pro);

//       // combine to create the Cross-Section
//       // It is the same conundrum... I am making the cross-section for all the Es bins
//       // in the created phase-space, BUT we are asuming that the bins in proton and neutron
//       // are the same, here they are the same, but is it true for every kinematics?
//       // I will use the proton bins
     
//       MakeCross(vvEspro, vvnupro, vvF1neu, vvF2neu, vvF1pro, vvF2pro, WFolder);
//       break;
//     default:
      
//       break;
//     }
  
  
// }



//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

int main(int argc, char *argv[])
{
  Variables = new HCVariables();
  
  
  TApplication *theApp = new TApplication("app", &argc, argv); //<======

  cout << "Compiled on: " __DATE__ " " __TIME__ "." << endl;
  
  TStopwatch timer;
  timer.Start();

  // TString inifile = "options.ini";

  gStyle->SetOptFit(1);
  gStyle->SetStatFormat("6.6g");

  // variable(inifile);
  // Variables->LoadFromFile(inifile);
  
  HCSelectProcess a;
  a.SelectProcess();
  // SelectProcess(Variables->massTarget, Variables->typeTarget, Variables->WorkFolder );

  timer.Stop();
  
  Double_t rtime = timer.RealTime();
  Double_t ctime = timer.CpuTime();

  printf("RealTime=%f seconds, CpuTime=%f seconds\n",rtime,ctime);

  cout << "-----> CTRL+C to end" << endl;
  
  theApp->Run();

  delete Variables;
  
  return 1;
}







//*********************************************************************************************
//                     AUXILIARY FUNCTIONS (NOT IMPORTANT FOR THE ANALYSIS)
//*********************************************************************************************

//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// In principle the numbers rounded can be stored directly in the file
// but they wwill be needed in a calculus later on.

Double_t round_number2(Double_t Num)
{
  // setprecision() is a great tool to round the number up/down
  // but it only works for stream (like cout). With some C++ -fu
  // the output is forward to a string (stringstream) and then converted
  // to double precision with 2 significant figures (in this case)
  // I choose 2 figures, because the steps to calculate nu=E-E' will
  // be in 0.1GeV steps

  stringstream ss;

  ss<< setprecision(2) << Num<< endl; 
  Double_t rounded = stod(ss.str());

  cout<<"ss: "<<rounded<<endl;    

  return rounded;
}

//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

Double_t round_number3(Double_t Num)
{
  // same as the previous function but to three significant figures
  // since the steps in Es for a given Ep bin will be in 

  stringstream ss;

  ss<< setprecision(3) << Num<< endl; 
  Double_t rounded = stod(ss.str());

  // cout<<"ss: "<<rounded<<endl;    

  return rounded;
}
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
