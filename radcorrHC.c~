// NOTES:
// The output folders must be constructed previously to run the script
#include "TSystem.h"

void create_space_phase();
Double_t round_number2(Double_t);
Double_t round_number3(Double_t);

void create_space_phase()
{

  // In the bin selection, I am taking the lower limit of the bin
  // but in the momentum selection, I am including the last value in the
  // selection. 
  
  Double_t rad2deg = 180./(4.*atan(1.));

     
  //***************  KIN SET  ************************

  const  Int_t nbins = 10;

  // Es_max = E_beam --> Max Es corresponds to energy beam.
  // Maybe move to the ini file in case we want to test
  // lower energies?
  
  Double_t Es_max = 10.38 ;
  Double_t Es_min;

 
  // IN PRINCIPLE, Ep_min should be determine by the experiment
  // to the ini file
  Double_t Ep_min = 3.78;  
  Double_t Ep_max;

  // Angle of the spectrometer (kinematics)
  // to the ini file
  Double_t Theta =  9.6/rad2deg; // min acceptance angle Murchana thesis
 

  // to the constants (in GeV)
  Double_t  mp = 0.938272 ;//proton mass
  Double_t  mn = 0.939565 ;//neutron mass
  Double_t  mHe3 = 2.81 ;// GeV. 3 uma
  Double_t  mpion = 0.140 ;// pion mass 

  //***************************************************************************************************************
  Double_t  mNuc = mp; // nucleon mass to use (not implemented yet in general form) <--- THIS IS IMPORTANT FOR THE REST OF THE CODE
  //***************************************************************************************************************


  // Threshold
  // to the ini file
  Double_t Wthreshold = 2. ;//DIS regime
  Double_t W2threshold = pow(Wthreshold,2); 

   
  Double_t sinsq = pow(sin((Theta)/2.),2); //sin^2(theta/2);

  ofstream outfileDIS;

  
  // These lines calculate the min/max points of the thresholds

  const Int_t Es_bins = 90;
  Int_t DISbins;
   
  vector<Double_t> vgrEsDIS;

  vector<Double_t> vgrEpDIS;

  Double_t grEsDIS[nbins+1][Es_bins+1]; 

  Double_t grEpDIS[nbins+1][Es_bins+1]; 


  outfileDIS.open(Form("./KINA_HMS_DIS/Theta.%.2f.Eprime.%.2f.dat", Theta*rad2deg, Ep_min  )  );

	   
  // round the value up to two significant figures
  cout<<"Epi: "<<Epi<<endl;
  cout<<"EsminDIS: "<<(W2threshold - pow(mNuc,2) + 2*mNuc*Ep_min )/( 2*mNuc - 4*Ep_min  *sinsq)<<endl;

  
  EsminDIS = round_number2((W2threshold - pow(mNuc,2) + 2*mNuc*Ep_min )/( 2*mNuc - 4*Ep_min  *sinsq) );
  
  // I don't need to store the round maximum value, but it is calculated for sanity
  EpmaxDIS   = ( pow(mNuc,2) + 2*mNuc*Es_max - W2threshold )/( 2*mNuc + 4*Es_max*sinsq);
  
  // we need to calculate the number of bins from Es_min and Es_max (10.300) with 0.1 GeV spacing
  // because we round Es_min up to two significatn figures, we assure that the number of bins
  // is integer, not just because we defined it integer (that would truncate the number)
  // Last bin, as suggested by Melanie's theses, will be of 0.8 and added later
  DISbins = ((Es_max - 0.080 ) - EsminDIS  ) /(0.1 );

	   
  //*****************************************************************
  // These lines created the spectrum of Ep vs Es in steps of 0.1 GeV
  // and rounded to the 3erd decimal
  //*****************************************************************
  for (int DISidx = 0; DISidx <= DISbins; DISidx++)
    {
      vgrEsDIS  .push_back(EsminDIS   + 0.1 *DISidx);
      vgrEpDIS  .push_back(round_number3(( pow(mNuc,2) + 2*mNuc*vgrEsDIS[DISidx] - W2threshold)/( 2*mNuc + 4*vgrEsDIS[DISidx]*sinsq) ) );
      
    }
  vgrEsDIS  .push_back(10.38 );
  vgrEpDIS  .push_back(round_number3(( pow(mNuc,2) + 2*mNuc*vgrEsDIS[DISbins+1] - W2threshold) /( 2*mNuc + 4*vgrEsDIS[DISbins+1]*sinsq)) );
  
  
	   

	  
  //*********************************************************************************
  // These lines store in a ASCII file the Ep-bin vs Es-bin for each Ep_min and Theta
  // rounded to the second decimal (Es) and third decimal (Ep)
  // Also creates the folder with the .dat files with the steps to feed the models
  // It is legacy from the original script. Now we have just one phase space, thus
  // it is just one folder
  
   for (int gr_idx0 = 0; gr_idx0 < vgrEsDIS.size(); gr_idx0++)
   {
      outfileDIS   << fixed<< setprecision(3)<< vgrEsDIS  [gr_idx0]<<" "<< vgrEpDIS  [gr_idx0] <<"\n";
   }
  //*********************************************************************************

  //	   cout<<"Es size: "<< vgrEsELA  .size()<<" Ep size: "<< vgrEpELA  .size()<<" ELABins: "<< ELAbins<<endl;  
  outfileDIS  .close();

  scriptDIS.close();
  angle_fol = Form("%2.2f", Theta *rad2deg);
  string nucleon;
  if(mNuc == mp)
    {
      nucleon = "proton";
    }
  else
    {
      nucleon = "neutron";
    }
  
  TString folderDIS00= "./KINA_DIS/";
  TString folderDIS01= "./KINA_DIS/"+angle_fol+"deg/";
  TString folderDIS02= "./KINA_DIS/"+angle_fol+"deg/"+nucleon;
 
  gSystem->MakeDirectory(folderDIS00);
  gSystem->MakeDirectory(folderDIS01);
  gSystem->MakeDirectory(folderDIS02); 

  //************** GRAPH THE PHASE-SPACE*****************
  //***  although it seems to have the same loops as  ***
  //***  shown above, these lopps cannot be avoided   ***
  //***  because they need to work with already       ***
  //***  calculated values, not on the fly            ***
  //*****************************************************

  TCanvas *c2;
  c2 = new TCanvas("c2","A Simple Graph Example",200,10,700,500);
  // c2->Divide(5,2);
  c2->cd();
     
   
  TGraph *grDIS;
  TAxis *axisDIS; 
  TLine *DISlineH;
  TLine *DISlineV;
  
    TLine *INElineStepV[100];
  TLine *INElineStepH[100];
      
  grDIS   = new TGraph(vgrEsDIS  .size(), &vgrEsDIS  [0] , &vgrEpDIS  [0]);
  axisDIS   = grDIS  ->GetXaxis();
  axisDIS   -> SetLimits(5. ,11. ); 
  grDIS   -> GetHistogram()->SetMaximum(8. );   // along          
  grDIS   -> GetHistogram()->SetMinimum(3. ); 
    
    
    
  grDIS   ->SetFillColor(10);
  grDIS   ->SetLineColor(kPink);
  grDIS   ->SetLineWidth(4);
  grDIS   ->SetMarkerColor(4);
  grDIS   ->SetMarkerStyle(8);

  grDIS   ->SetTitle(Form("Phase Space HMS Kin A -- #Theta = %.2f deg", Theta *rad2deg) );
  grDIS   ->Draw("AL");
  grDIS   ->GetHistogram()->SetXTitle("Es (MeV)");
  grDIS   ->GetHistogram()->SetYTitle("Ep (MeV)");
      

  DISlineH   = new TLine(EsminDIS   ,  Ep_min  , Es_max,  Ep_min  );
  DISlineH   ->SetLineWidth(4);
  DISlineH   ->SetLineColor(kPink);
  DISlineH   ->Draw("same");
	   
	   
  DISlineV    = new TLine(Es_max, Ep_min  , Es_max, EpmaxDIS   );
  DISlineV    ->SetLineWidth(4);
  DISlineV    ->SetLineColor(kPink);
  DISlineV    ->Draw("same");
	   
  for (int stepH = 0; stepH < 47; stepH++)
     {
       INElineStepV[stepH]  = new TLine(EsminDIS+ (0.1*stepH ), Ep_min, EsminDIS+ (0.1*stepH ), EpmaxDIS );
       INElineStepV[stepH]  ->SetLineWidth(1);
       INElineStepV[stepH]  ->SetLineColor(kBlack);
       INElineStepV[stepH]  ->Draw("same");
     }
   
   for (int stepV = 0; stepV < 39; stepV++)
     {
       INElineStepH[stepV]  = new TLine(EsminDIS, Ep_min + (0.1*stepV ) , Es_max, Ep_min + (0.1*stepV ) );
       INElineStepH[stepV]  ->SetLineWidth(1);
       INElineStepH[stepV]  ->SetLineColor(kBlack);
       INElineStepH[stepV]  ->Draw("same");
     }

}

// In principle the numbers rounded can be stored directly in the file
// but they wwill be needed in a calculus later on.

Double_t round_number2(Double_t Num)
{
  // setprecision() is a great tool to round the number up/down
  // but it only works for stream (like cout). With some C++ -fu
  // the output is forward to a string (stringstream) and then converted
  // to double precision with 2 significant figures (in this case)
  // I choose 2 figures, because the steps to calculate nu=E-E' will
  // be in 0.1GeV steps

  stringstream ss;

  ss<< setprecision(2) << Num<< endl; 
  Double_t rounded = stod(ss.str());

  cout<<"ss: "<<rounded<<endl;    

  return rounded;
}


Double_t round_number3(Double_t Num)
{
  // same as the previous function but to three significant figures
  // since the steps in Es for a given Ep bin will be in 

  stringstream ss;

  ss<< setprecision(3) << Num<< endl; 
  Double_t rounded = stod(ss.str());

  // cout<<"ss: "<<rounded<<endl;    

  return rounded;
}




int main(int argc, char *argv[])
{

  TApplication *theApp = new TApplication("app", &argc, argv); //<======

  cout << "Compiled on: " __DATE__ " " __TIME__ "." << endl;
  
  TStopwatch timer;
  timer.Start();
  
  gStyle->SetOptFit(1);
  gStyle->SetStatFormat("6.6g");

  create_space_phase();
  timer.Stop();
  
  Double_t rtime = timer.RealTime();
  Double_t ctime = timer.CpuTime();

  printf("RealTime=%f seconds, CpuTime=%f seconds\n",rtime,ctime);

  cout << "-----> CTRL+C to end" << endl;
  
  theApp->Run();


  
  return 1;
}
