#include "HCSpectra.hh"
#include "Rtypes.h"

#include <iostream>
#include "string.h"
#include "string"
#include <fstream>
#include <sstream>

#include "TString.h"
#include "HCSpacePhase.hh"
#include "HCSelectProcess.hh"

using namespace std;



HCSpectra::HCSpectra()
{
  cout << "<HCSpectra::HCSpectra>: LOADING" << endl;
  // PSpace  = new HCSpacePhase() ; 

}

HCSpectra::~HCSpectra()
{
  cout << "<HCSpectra::~HCSpectra>: END" << endl;
}


void HCSpectra::CreateSpectra()
{


  
  cout<<"*******create spectra*************"<<endl;
  

  cout<<"Theta: "<<Variables->gTheta<<endl;

  angle_fol = Form("/%2.2f", Variables->gTheta);
  
  TString folder01= Variables->WorkFolder+angle_fol+"deg/"; 
  TString folder02 = folder01+Variables->nucleon;

  cout<<"folder01"<<folder01<<endl;
  cout<<"folder02"<<folder02<<endl;
  
  gSystem->MakeDirectory(folder01);
  gSystem->MakeDirectory(folder02); 

  // The folder02 is the FinalFolder used internally in the rest of the code
  // it is specific for the angle set in options.ini
  // Perhaps it should be improved for similar angle but other characteristics
  // as is right now, it will overwrite any data present.

  // Keeping the philosophy of working without reading any of the created files
  // we need to store the output here in containers to send to the next method
  // but we save the data as was done with the single scripts

   
  Int_t file_id = 0;
  Int_t file_idx =0;

  
  //  vEs = SP.vEs_PS;
  vEs = PSpace->vEs_PS;
  vEp = PSpace->vEp_PS;
  

  int NoEsBins = vEp.size();
  Double_t delta = 0;

  cout<<NoEsBins<<" "<<endl;
  
  gSystem->MakeDirectory(folder02+"/spectra");
  
  for (int idx = 0; idx< NoEsBins; idx++)
    {
      Es = vEs[idx];
      Ep = vEp[idx];
      EpDelta = Ep;
      
      fileDIS = folder02+"/spectra"+Form("/%d.dat", file_id );
      cout<<fileDIS<<endl;
      spectra.open(fileDIS);
      
      while( EpDelta >=(CSEp_min -(0.001) ) )
	{
	  nu = Es - EpDelta;
	  vEs.push_back(Es);
	  vEp.push_back(EpDelta);
	  vnu.push_back(nu);
	  
	  spectra<< Es<<" "<<EpDelta<<" "<<nu<<"\n";
	  delta++;
	  EpDelta = Ep - 0.01* delta;
	}

      // There are two ways to pass the data to the clas model
      // I can pass it as the spectrum is created
      // so, just need to call the function here and pass
      // the vector with the info of the present spectra
      // The other option, used here, is to pass the whole information
      // Probably, in memory usage, the first is more efficient
      
      vvnuCS.push_back(vnu);
      vvEsCS.push_back(vEs);
      vvEpCS.push_back(vEp);

      vEs.clear();
      vEp.clear();
      vnu.clear();
      
      spectra.close();
      file_id++;
      // clas_model method should be called here.
      // the arguments should be vectors of Es, Ep(steps), nu, file_id
      delta = 0;

    }

  cout<<"size: "<<vvnuCS.size()<<endl;
  
}

double HCSpectra::Theta()
{
  return Variables->gTheta/rad2deg; 
}

HCSpectra *Spectra=NULL;
