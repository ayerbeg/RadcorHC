#include "HCModel.hh"
#include "Rtypes.h"

#include <iostream>
#include "string.h"
#include "string"
#include <fstream>
#include <sstream>

#include "TString.h"

using namespace std;



HCModel::HCModel()
{
  cout << "<HCModel::HCModel>: LOADING" << endl;
 
}

HCModel::~HCModel()
{
  cout << "<HCModel::~HCModel>: END" << endl;
}

void HCModel::clas_model(TString storeFolderCM,
		TString nucleonCM,
		double mNuc,
		vector<vector<double>>EsCM,
		vector<vector<double>>nuCM,
		vector<vector<double>>EpCM,
		vector<vector<double>> &vvF1CM,
		vector<vector<double>> &vvF2CM
		)
{

  cout<<"***********CLAS model***************"<<endl;
  cout<<storeFolderCM<<endl;


  Theta = Variables->gTheta/rad2deg;
  cout<<"Theta: "<<gTheta<<endl;


  // THESE LINES ARE STRONGLY RELATED WITH THE CLAS SUBROUTINE
  // I SHOULD TAKE CARE MODIFYING THEM

  // These lines are necesary to simplify the conversion from
  // string to char needed by the fortran subroutine
  char creso;
  if( (varreso == "y")||(varreso == "Y"))
    {
      creso = 'y' ;
    }
  else
    {
      creso = 'n' ;
    }
  
  char Target; // A lot to understand here.

  int typeTarget;
  //  Target_rad(mNuc, typeTarget); // it doesn't work when the target is He3

  const char* nucle;  
  // Same as before (remember we are using global variables)
  if(Variables->nucleon == "proton")
    {
      Target = 'P';
      nucle = "p";  
    }
  else
    {
      Target = 'N';
      nucle = "n";  
    }

  
  cout<<  varIPOL<<" "<<varIA1<<" "<< varAsym<<" "<<varreso<<" "<<Target<<endl;

  string line;
  string it1, it2, it3; // MY FILES HAVE Es, Ep and nu = (Es-Ep)
  Double_t Es, Ep, nu;

  Int_t file_id = 0;

  bool fileexist = true;

  TString SaveData = Form(storeFolderCM+"/SF%s",nucle);
  gSystem->MakeDirectory(SaveData);


  cout<< SaveData<<endl;  
  // THIS LOOP KEEPS READING THE FILES IN A GIVEN FOLDER (THE ONE DEFDISD BY Ep)


  int NoOfSpectra = EsCM.size();// somehow, this is the number of spectra (the file id)
  cout<<"Hello "<< NoOfSpectra<<endl;
  
  for(int spectraIDX = 0; spectraIDX < NoOfSpectra; spectraIDX++)
    {
   
      int NoOfPoints = EsCM[spectraIDX].size();// this is the number of data points in the spectra
      file_id = spectraIDX;

      ofstream SaveFile(SaveData+Form("/%sSF_%d.dat",Theta*rad2deg,  nucle, file_id ));
 
      for(int SpecPointsIDX = 0; SpecPointsIDX < NoOfPoints; SpecPointsIDX++)
	{

	  Es = EsCM[spectraIDX][SpecPointsIDX];
	  Ep = EpCM[spectraIDX][SpecPointsIDX]; 
	  nu = nuCM[spectraIDX][SpecPointsIDX]; 
  

	  Q2 = calcQ2(Es,Ep, Theta );
	  W2 = calcW2(mNuc, nu, Q2);

	  
	  strucfunc_(&file_id, &W2, &Q2, &Target, &varYoniIndex, &varIPOL, &varIA1, &varSFC, &varAsym, &creso, &F1, &F2, &g1, &g2, &A1, &A2 );

	  // with the option 'fixed' every value carries the same number of digits, filling with zeroes when necessary
	  // Data saved: Es -- nu -- W2 -- Q2 -- F1 -- F2 -- g1 -- g2
	  SaveFile<<fixed<<Es<<"\t"<<nu<<"\t" << W2 <<"\t"<<Q2<<"\t"<< F1<<"\t"<< F2<<"\t"<< g1<<"\t"<< g2 << endl;
	  //	  cout<<fixed<<Es<<"\t"<<nu<<"\t" << W2 <<"\t"<<Q2<<"\t"<< F1<<"\t"<< F2<<"\t"<< g1<<"\t"<< g2 << endl;

	  vF1.push_back(F1);
	  vF2.push_back(F2);
	}
      
      vvF1CM.push_back(vF1);
      vvF2CM.push_back(vF2);

      vF1.clear();
      vF2.clear();
      SaveFile.close();
     }

  if(  plotStructureF) // it plots THE LAST bin of the phase-space (the list starts at 0)
    PlotSF(nuCM[NoOfSpectra-1], vvF1CM[NoOfSpectra-1],  vvF2CM[NoOfSpectra-1]);


    
  // can we combine the previous work in order to calculate THIS:
  //  XS = CrossSection(Es, nu, Theta, 2*pF1+nF1,  2*pF2+nF2);
  // probably it needs an extra function where it call the method twice

}





//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-



  
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

// suffix MC for MakeCross (this function)
void HCModel::MakeCross(vector<vector<double>> vvEsMC,
	       vector<vector<double>> vvnuMC,
	       vector<vector<double>> vvF1neuMC,
	       vector<vector<double>> vvF2neuMC,
	       vector<vector<double>> vvF1proMC,
	       vector<vector<double>> vvF2proMC,
	       TString SaveFolder)
{
  cout<<"*********** Make Cross ***************"<<endl;

  double Theta =  gTheta/rad2deg;
  cout<<"Theta: "<<gTheta<<endl;
  TString SaveData =(SaveFolder + Form("/%2.2fdeg/He3CrossSection", Theta *rad2deg));
  gSystem->MakeDirectory(SaveData);
  cout<<SaveData<<endl;

  
  Double_t Es, nu, Ep,  W2, Q2, g1, g2; // Es and nu are common for n and p, W2 and Q2 are not used. g1 and g2 are in stand-by
  Double_t pF1, pF2, nF1, nF2;

  Double_t XS;

  vector<double> vXS;
  vector<vector<double>> vvXS;

  double mHe3 = 2.81 ;// GeV. 3 uma

  int NoOfSpectra = vvEsMC.size();// somehow, this is the number of spectra (the file id)
  cout<<"Hello "<< NoOfSpectra<<endl;

  cout<<vvnuMC.size()<<" "<<vvF1neuMC.size()<<" "<<vvF2neuMC.size()<<" "<<vvF1proMC.size()<<" "<<vvF1proMC.size()<<endl;
  
  Int_t file_id = 0;
  for(int spectraIDX = 0; spectraIDX < NoOfSpectra; spectraIDX++)
    {
 
      int NoOfPoints = vvEsMC[spectraIDX].size();// this is the number of data points in the spectra
      file_id = spectraIDX;

      ofstream  SaveFile(SaveData +Form("/XS%2.2f_%d.dat", Theta*rad2deg, file_id ));
 
      for(int SpecPointsIDX = 0; SpecPointsIDX < NoOfPoints; SpecPointsIDX++)
	{

	  // All units are in GeV, but the cross-section is handled in MeV
	  // so, we convert all to MeV (1e3) but at the end of the process
	  
	  Es = vvEsMC[spectraIDX][SpecPointsIDX]; 
	  nu = vvnuMC[spectraIDX][SpecPointsIDX]; 
	  
	  Q2 = calcQ2(Es, Es-nu, Theta); 
	  W2 = calcW2(mHe3, nu, Q2)*pow(1e3,2);       //in MeV^2

	  
	  pF1 = vvF1proMC[spectraIDX][SpecPointsIDX];   
	  pF2 = vvF2proMC[spectraIDX][SpecPointsIDX]; 
	  
	  nF1 = vvF1neuMC[spectraIDX][SpecPointsIDX];  
	  nF2 = vvF2neuMC[spectraIDX][SpecPointsIDX];  
	  
	  XS = He3CrossSection(Es*1e3, nu*1e3, Theta, 2*pF1+nF1,  2*pF2+nF2);
	  
	  SaveFile<< Es*1e3 << "\t" <<nu*1e3  << "\t"<< sqrt(W2) << "\t" <<XS<<"\t"<<0.0<<endl;
	  //	  cout<<fixed<< Es*1e3 << "\t" <<nu*1e3  << "\t"<< sqrt(W2) << "\t" <<XS<<"\t"<<0.0<<endl;
	  vXS.push_back(XS);
	}
      vvXS.push_back(vXS);
      vXS.clear();
      SaveFile.close();
    }


  
  cout<<"bool: "<<plotCrossSecHe3<<endl;
  if( plotCrossSecHe3)
    PlotHe3XS(vvnuMC[NoOfSpectra-1], vvXS[NoOfSpectra-1]);

}


//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

double HCModel::He3CrossSection( Double_t tE,  Double_t tnu, Double_t  tAngle, Double_t  tF1,  Double_t tF2)
{
  // tE incoming energy, tnu energy difference, tAngle scattering angle, tF1 = F1n + 2F1p (same F2)
  // units converted already in MeV from GeV


  // I think I missed a factor cos^2 in the formula
  
  double mHe3 = 2.81*1e3;//in MeV  3 uma
  double alpha = 1/137.;
  double hbarc = 197.32698;
  double mott = pow(alpha, 2)/(4*(tE*tE)*pow(sin(tAngle/2.), 4));
  double cross =pow(cos(tAngle/2.), 2)* ((tF2/(tnu))+((2*tF1*pow(tan(tAngle/2.), 2))/mHe3));
  
  return mott*cross*(hbarc*hbarc)*1e7;
  // the convertion factor from 1/MeV^3 -> nb/MeV
}


//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

double HCModel::calcQ2(double Ei, double Ef, double Th)
{
  return Ei*Ef*4*sin(Th/2.)*sin(Th/2.);
}
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
double HCModel::calcW2(double mp, double nulocal, double Q2local)
{
  return mp*mp + (2*mp*nulocal) - Q2local;
}
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-








HCModel *Model=NULL;
