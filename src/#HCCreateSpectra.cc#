#include "HCCreateSpectra.hh"
#include "Rtypes.h"

#include <iostream>
#include "string.h"
#include "string"
#include <fstream>
#include <sstream>

#include "TString.h"


#include "HCVariables.hh"

using namespace std;



HCCreateSpectra::HCCreateSpectra()
{
  cout << "<HCCreateSpectra::HCCreateSpectra>: LOADING" << endl;
  //  inputfile = "options.ini";
}

HCCreateSpectra::~HCCreateSpectra()
{
  cout << "<HCCreateSpectra::~HCCreateSpectra>: END" << endl;
}





HCCreateSpectra::void CreateSpectra()
{

  cout<<"*******create spectra*************"<<endl;
  

  double Theta =  Variables->gTheta/rad2deg;
  cout<<"Theta: "<<Variables->gTheta<<endl;
  
  TString angle_fol;

  angle_fol = Form("/%2.2f", Theta *rad2deg);
  
  TString folder01= mainFolder+angle_fol+"deg/"; 
  folder02= folder01+nucFolder;
 
  gSystem->MakeDirectory(folder01);
  gSystem->MakeDirectory(folder02); 

  // The folder02 is the FinalFolder used internally in the rest of the code
  // it is specific for the angle set in options.ini
  // Perhaps it should be improved for similar angle but other characteristics
  // as is right now, it will overwrite any data present.

  // Keeping the philosophy of working without reading any of the created files
  // we need to store the output here in containers to send to the next method
  // but we save the data as was done with the single scripts

  ofstream spectra;
  
  Int_t file_id = 0;

  Double_t Es, Ep;

  Int_t file_idx =0;
  Double_t nu, EpDelta;

  // These vectors contain the data of a given Es bin
  vector<double> vEs;
  vector<double> vEp;
  vector<double> vnu;

  // These vectors contain all the spectra
  // vector<vector<double>> vvEsCS;
  // vector<vector<double>> vvEpCS;
  // vector<vector<double>> vvnuCS;
  
  int NoEsBins = vgrEs.size();
  Double_t delta = 0;


  
  gSystem->MakeDirectory(folder02+"/spectra");
  
  for (int idx = 0; idx< NoEsBins; idx++)
    {
      Es = vgrEs[idx];
      Ep = vgrEp[idx];
      EpDelta = Ep;

      
      TString fileDIS = folder02+"/spectra"+Form("/%d.dat", file_id );

      spectra.open(fileDIS);
      
      while( EpDelta >=(CSEp_min -(0.001) ) )
	{
	  nu = Es - EpDelta;
	  vEs.push_back(Es);
	  vEp.push_back(EpDelta);
	  vnu.push_back(nu);
	  
	  spectra<< Es<<" "<<EpDelta<<" "<<nu<<"\n";
	  delta++;
	  EpDelta = Ep - 0.01* delta;
	}

      // There are two ways to pass the data to the clas model
      // I can pass it as the spectrum is created
      // so, just need to call the function here and pass
      // the vector with the info of the present spectra
      // The other option, used here, is to pass the whole information
      // Probably, in memory usage, the first is more efficient
      
      vvnuCS.push_back(vnu);
      vvEsCS.push_back(vEs);
      vvEpCS.push_back(vEp);

      vEs.clear();
      vEp.clear();
      vnu.clear();
      
      spectra.close();
      file_id++;
      // clas_model method should be called here.
      // the arguments should be vectors of Es, Ep(steps), nu, file_id
      delta = 0;

    }

  cout<<"size: "<<vvnuCS.size()<<endl;
  
}





//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

void clas_model(TString storeFolderCM,
		TString nucleonCM,
		double mNuc,
		vector<vector<double>>EsCM,
		vector<vector<double>>nuCM,
		vector<vector<double>>EpCM,
		vector<vector<double>> &vvF1CM,
		vector<vector<double>> &vvF2CM
		)
{

  cout<<"***********Clas model***************"<<endl;
  cout<<storeFolderCM<<endl;


  double Theta =  Variables->gTheta/rad2deg;
  cout<<"Theta: "<<Variables->gTheta<<endl;
  // These lines are necesary to simplify the conversion from
  // string to char needed by the fortran subroutine
  char creso;
  if( (Variables->varreso == "y")||(Variables->varreso == "Y"))
    {
      creso = 'y' ;
    }
  else
    {
      creso = 'n' ;
    }
  
  char Target; // A lot to understand here.

  int typeTarget;
  //  Target_rad(mNuc, typeTarget); // it doesn't work when the target is He3

  const char* nucle;  
  // Same as before (remember we are using global variables)
  if(nucleonCM == "proton")
    {
      Target = 'P';
      nucle = "p";  
    }
  else
    {
      Target = 'N';
      nucle = "n";  
    }

  
 


  // SF data/spectra
  vector<double> vF1;
  vector<double> vF2;



  
  // THE RETURNED VALUES ACCORDING TO DARREN UPTON DOCUMENT
  // MAYBE WE DON'T NEED ALL OF THEM FOR THE RADIATIVE CORRECTIONS
  // BUT WE CAN KEEP THEM FOR FURTHER ANALYSIS

  Double_t Q2;  // transfer momentum
  Double_t W2;  // invariant mass
  Double_t xbj; // x Bjorken
  Double_t F1=0;  // unpolarized SF1
  Double_t F2=0;  // unpolarized SF2
  Double_t R;   // ?
  Double_t A1;  // asymmetry A1
  Double_t A2;  // asymmetry A2 (?)
  Double_t g1=0;  // polarized SF1
  Double_t g2=0;  // polarized SF2


  string line;
  string it1, it2, it3; // MY FILES HAVE Es, Ep and nu = (Es-Ep)
  Double_t Es, Ep, nu;


  int SFC = Variables-> varSFC ;
  int Asym = Variables-> varAsym;
  int IA1 = Variables->varIA1;
  int IPOL = Variables->varIPOL; 
  int YoniIndex = Variables->varYoniIndex;
 cout<<  IPOL<<" "<<IA1<<" "<< Asym<<" "<<Target<<endl;
  
  
  Int_t file_id = 0;


  bool fileexist = true;


  TString SaveData = Form(storeFolderCM+"/SF%s",nucle);
  gSystem->MakeDirectory(SaveData);


  cout<< SaveData<<endl;  
  // THIS LOOP KEEPS READING THE FILES IN A GIVEN FOLDER (THE ONE DEFDISD BY Ep)


  int NoOfSpectra = EsCM.size();// somehow, this is the number of spectra (the file id)
  cout<<"Hello "<< NoOfSpectra<<endl;
  
  for(int spectraIDX = 0; spectraIDX < NoOfSpectra; spectraIDX++)
    {
   
      int NoOfPoints = EsCM[spectraIDX].size();// this is the number of data points in the spectra
      file_id = spectraIDX;

      ofstream SaveFile(SaveData+Form("/%sSF_%d.dat",Theta*rad2deg,  nucle, file_id ));
 
      for(int SpecPointsIDX = 0; SpecPointsIDX < NoOfPoints; SpecPointsIDX++)
	{

	  Es = EsCM[spectraIDX][SpecPointsIDX];
	  Ep = EpCM[spectraIDX][SpecPointsIDX]; 
	  nu = nuCM[spectraIDX][SpecPointsIDX]; 
  

	  Q2 = calcQ2(Es,Ep, Theta );
	  W2 = calcW2(mNuc, nu, Q2);

	  
	  strucfunc_(&file_id, &W2, &Q2, &Target, &YoniIndex, &IPOL, &IA1, &SFC, &Asym, &creso, &F1, &F2, &g1, &g2, &A1, &A2 );

	  // with the option 'fixed' every value carries the same number of digits, filling with zeroes when necessary
	  // Data saved: Es -- nu -- W2 -- Q2 -- F1 -- F2 -- g1 -- g2
	  SaveFile<<fixed<<Es<<"\t"<<nu<<"\t" << W2 <<"\t"<<Q2<<"\t"<< F1<<"\t"<< F2<<"\t"<< g1<<"\t"<< g2 << endl;
	  //	  cout<<fixed<<Es<<"\t"<<nu<<"\t" << W2 <<"\t"<<Q2<<"\t"<< F1<<"\t"<< F2<<"\t"<< g1<<"\t"<< g2 << endl;

	  vF1.push_back(F1);
	  vF2.push_back(F2);
	}
      
      vvF1CM.push_back(vF1);
      vvF2CM.push_back(vF2);

      vF1.clear();
      vF2.clear();
      SaveFile.close();
     }

  if(  plotStructureF) // it plots THE LAST bin of the phase-space (the list starts at 0)
    PlotSF(nuCM[NoOfSpectra-1], vvF1CM[NoOfSpectra-1],  vvF2CM[NoOfSpectra-1]);


    
  // can we combine the previous work in order to calculate THIS:
  //  XS = CrossSection(Es, nu, Theta, 2*pF1+nF1,  2*pF2+nF2);
  // probably it needs an extra function where it call the method twice

}

